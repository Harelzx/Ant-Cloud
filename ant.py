# -*- coding: utf-8 -*-
"""Ant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jvb-2g847mi9qIxI5MOErTlKstGfZVcd

Block 1: Install Libraries and Import Modules
"""

# Install required packages
!pip install python-firebase requests pandas paho-mqtt beautifulsoup4 nltk
# Install widget support
!pip install -q ipywidgets
# Import all required modules
import requests
from IPython.display import display, HTML, clear_output
import json
import pandas as pd
from datetime import datetime, timedelta
import paho.mqtt.client as mqtt
import time
from bs4 import BeautifulSoup
import re
from collections import defaultdict
import nltk
nltk.download('stopwords')
nltk.download('wordnet')
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
import ipywidgets as widgets
import matplotlib.pyplot as plt
import random
import os

"""Block 2: Global Constants and Variables"""

# Set your Firebase Realtime Database URL here
FIREBASE_URL = "https://optidash-fc87a-default-rtdb.europe-west1.firebasedatabase.app/"

# Thresholds for parameter values
THRESHOLDS = {
    'Temperature': {'low': 18, 'high': 30},
    'Humidity': {'low': 30, 'high': 70},
    'Pressure': {'low': 900, 'high': 1050},
    'DLIGHT': {'low': 100, 'high': 2000},
    'Distance': {'low': 0, 'high': 300}
}

# Thresholds for fast changes in parameters
FAST_DELTA = {
    'Temperature': 2.0,
    'Humidity': 8.0,
    'Pressure': 15,
    'DLIGHT': 200,
    'Distance': 40
}

# Global variables
mqtt_data = {"indoor": [], "outdoor": []}
df_indoor = pd.DataFrame()
df_outdoor = pd.DataFrame()
admin_log = []
alerts_list = []

"""Block 3: Firebase Functions"""

def save_to_firebase(topic, data):
    """
    Save a new record under sensors/<topic> in Firebase using the REST API.
    Args:
        topic (str): Either "indoor" or "outdoor"
        data (dict): The sensor data to be saved
    """
    url = f"{FIREBASE_URL}sensors/{topic}.json"
    resp = requests.post(url, json=data)
    if resp.status_code != 200:
        print(f"Failed to save to Firebase: {resp.text}")

def load_from_firebase(topic):
    """
    Load all records from Firebase under sensors/<topic> and process them.
    """
    url = f"{FIREBASE_URL}sensors/{topic}.json"
    resp = requests.get(url)
    if resp.status_code != 200:
        print(f"Failed to load from Firebase: {resp.text}")
        return []

    data = resp.json()
    if not data:
        return []

    records = list(data.values())

    # For indoor data, process and fill missing values
    if topic == "indoor":
        # Sort records by timestamp
        records.sort(key=lambda x: x.get('timestamp', ''))

        # Dictionary with the latest value received for each field
        latest_values = {}

        # Process each record and fill missing data from previous records
        for record in records:
            # Update latest values
            for field in ['Distance', 'Pressure', 'Temperature', 'Humidity']:
                if field in record and record[field] is not None:
                    latest_values[field] = record[field]

            # Fill missing values
            for field in ['Distance', 'Pressure', 'Temperature', 'Humidity']:
                if field not in record or record[field] is None:
                    if field in latest_values:
                        record[field] = latest_values[field]

        # Filter records with sufficient data
        processed_records = []
        for record in records:
            # Add only records with at least 2 fields filled out of the four
            fields_count = sum(1 for field in ['Distance', 'Pressure', 'Temperature', 'Humidity']
                               if field in record and record[field] is not None)
            if fields_count >= 2 and 'timestamp' in record:
                processed_records.append(record)

        return processed_records

    # For outdoor data, filter irrelevant fields
    elif topic == "outdoor":
        # List of allowed fields for outdoor
        allowed_fields = ['DLIGHT', 'Temperature', 'Humidity', 'timestamp']

        # Process each record and clean irrelevant fields
        cleaned_records = []
        for record in records:
            cleaned_record = {k: v for k, v in record.items() if k in allowed_fields}
            # Ensure there's at least one field besides timestamp
            if len(cleaned_record) > 1:  # At least one field + timestamp
                cleaned_records.append(cleaned_record)

        return cleaned_records

    return records

"""# Block 4a: Data Initialization and MQTT Handler"""

def load_initial_data():
    """Load existing data from Firebase"""
    global df_indoor, df_outdoor
    print("Loading initial data from Firebase...")
    indoor_records = load_from_firebase("indoor")
    outdoor_records = load_from_firebase("outdoor")

    if indoor_records:
        df_indoor = pd.DataFrame(indoor_records)
        print(f"Loaded {len(df_indoor)} indoor records")
    else:
        print("No indoor records found")

    if outdoor_records:
        df_outdoor = pd.DataFrame(outdoor_records)
        print(f"Loaded {len(df_outdoor)} outdoor records")
    else:
        print("No outdoor records found")

# MQTT message handler
def on_message(client, userdata, msg):
    global df_indoor, df_outdoor
    try:
        decoded = msg.payload.decode()
        data = json.loads(decoded)
        # Add timestamp
        data['timestamp'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        topic_parts = msg.topic.split("/")
        if "indoor" in topic_parts or "indoor_sensors" in topic_parts:
            # Handle Distance-only messages
            if "Distance" in data and len(data) == 1:
                save_to_firebase("indoor", {"Distance": data["Distance"], "timestamp": data['timestamp']})
            elif any(key in data for key in ["Pressure", "Temperature", "Humidity"]):
                row = {
                    "Pressure": data.get("Pressure"),
                    "Temperature": data.get("Temperature"),
                    "Humidity": data.get("Humidity"),
                    "timestamp": data['timestamp']
                }
                save_to_firebase("indoor", row)
            indoor_records = load_from_firebase("indoor")
            if indoor_records:
                df_indoor = pd.DataFrame(indoor_records)
        elif "outdoor" in topic_parts:
            # Rename "Day Light" to "DLIGHT" if present
            if "Day Light" in data:
                data["DLIGHT"] = data.pop("Day Light")
            row = {"timestamp": data['timestamp']}
            for field in ["DLIGHT", "Temperature", "Humidity"]:
                if field in data and data[field] is not None:
                    row[field] = data[field]
            save_to_firebase("outdoor", row)
            outdoor_records = load_from_firebase("outdoor")
            if outdoor_records:
                df_outdoor = pd.DataFrame(outdoor_records)
        # else: ignore unknown topics silently
    except Exception as e:
        # Optionally, log errors here for silent failures
        pass

"""Block 4b: MQTT Client Setup"""

# MQTT Client Setup and Background Listening

# MQTT connection settings
mqtt_broker = "test.mosquitto.org"
mqtt_port = 1883
topics = [("braude/D106/indoor", 0), ("braude/D106/outdoor", 0)]

# Create MQTT client
client = mqtt.Client()
client.on_message = on_message

# Connect to broker
try:
    print(f"Connecting to MQTT broker at {mqtt_broker}:{mqtt_port}...")
    client.connect(mqtt_broker, mqtt_port, 60)

    # Subscribe to topics
    for topic, qos in topics:
        client.subscribe(topic, qos)
        print(f"Subscribed to {topic} with QoS {qos}")

    # Start listening in a background thread
    print("DEBUG: Starting MQTT listener in background")
    client.loop_start()
    print("MQTT client started and listening in background - the system is now receiving real-time updates!")
except Exception as e:
    print(f"ERROR: Failed to connect to MQTT broker: {e}")

"""Block 5: Initial Data Loading and Verification

"""

# Load initial data from Firebase
load_initial_data()
# Display the number of records and the columns for each DataFrame
print(f"Number of indoor records: {len(df_indoor)}")
print(f"Number of outdoor records: {len(df_outdoor)}")

"""Block 6: Search Engine Implementation

"""

# Search Engine implementation

class SearchEngine:
    def __init__(self):
        """Initialize the search engine."""
        self.pages = []
        self.word_locations = defaultdict(list)  # word -> list of {'DocID': id, 'Title': title, 'Frequency': count}
        self.stop_words = set(stopwords.words('english'))
        custom = [
            'mqtt', 'c', 's', 'open', 'based', 'using'
        ]
        self.stop_words.update(custom)
        self.lemmatizer = WordNetLemmatizer()

    def is_valid_term(self, term):
        """Validate if a term should be included in the index."""
        if len(term) <= 2:
            return False
        if not re.match(r'^[a-zA-Z]+$', term):
            return False
        return True

    def fetch_pages(self, base_url, num_pages=5):
        """Fetch up to num_pages unique links (including the main page) from the base URL."""
        try:
            response = requests.get(base_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            links = []
            for a_tag in soup.find_all('a', href=True):
                full_url = requests.compat.urljoin(base_url, a_tag['href'])
                if full_url.startswith(base_url):
                    links.append(full_url)
            links = list(dict.fromkeys(links))  # preserve order, remove duplicates
            if base_url not in links:
                links = [base_url] + links
            links = links[:num_pages]
            print(f"Found {len(links)} links. Processing the first {num_pages}.")

            # mapping: id (int) ‚Üí url (string)
            self.id_url_map = {}
            for i, link in enumerate(links, 1):
                try:
                    page_response = requests.get(link)
                    page_soup = BeautifulSoup(page_response.text, 'html.parser')
                    for tag in page_soup(["script", "style", "meta", "link"]):
                        tag.decompose()
                    page_text = page_soup.get_text(" ", strip=True)
                    self.pages.append({
                        'id': i,  # numeric DocID
                        'title': page_soup.title.string if page_soup.title else 'No Title',
                        'url': link,
                        'content': page_text
                    })
                    self.id_url_map[i] = link
                    print(f"Retrieved: {link} (DocID {i})")
                except Exception as e:
                    print(f"Error processing {link}: {str(e)}")
            return True
        except Exception as e:
            print(f"Error fetching pages: {str(e)}")
            return False

    def build_index(self):
        """Build the word-location index using lemmatization and validation."""
        self.word_locations.clear()
        for page in self.pages:
            content = page['content']
            word_counts = defaultdict(int)
            for word in re.findall(r'\b\w+\b', content):
                word_lower = word.lower()
                if word_lower in self.stop_words or not self.is_valid_term(word_lower):
                    continue
                lemma = self.lemmatizer.lemmatize(word_lower)
                word_counts[lemma] += 1
            for word, count in word_counts.items():
                self.word_locations[word].append({
                    'DocID': page['id'],  # *** numeric DocID! ***
                    'Title': page['title'],
                    'Frequency': count
                })
        print("Local index built using Lemmatization!")

def search(query, engine, top_n=5):
    """
    Simple search function using the built index.
    Shows DocID, Title, and the real URL.
    """
    lemmatizer = engine.lemmatizer
    stop_words = engine.stop_words
    words = [lemmatizer.lemmatize(w.lower()) for w in re.findall(r'\w+', query)
             if w.lower() not in stop_words and engine.is_valid_term(w.lower())]
    result_pages = defaultdict(int)  # DocID -> score
    for word in words:
        for location in engine.word_locations.get(word, []):
            result_pages[location['DocID']] += location['Frequency']
    ranked = sorted(result_pages.items(), key=lambda x: -x[1])
    for doc_id, score in ranked[:top_n]:
        title = next(p['title'] for p in engine.pages if p['id'] == doc_id)
        url = engine.id_url_map[doc_id]
        print(f"DocID: {doc_id}\nTitle: {title}\nURL: {url}\nScore: {score}\n")

"""Block 7: Initialize Search Engine

"""

# Create and initialize search engine instance
engine = SearchEngine()
engine.fetch_pages("https://mqtt.org", num_pages=5)

# ‚Äî‚Äî‚Äî Frequency analysis for custom stop-words ‚Äî‚Äî‚Äî
from collections import Counter
import re

# Combine all fetched page text into one big lowercase string
all_text = " ".join(page['content'] for page in engine.pages).lower()

# Extract only alphabetic words and count occurrences
words = re.findall(r'\b[a-zA-Z]+\b', all_text)
freq  = Counter(words)

# Show the top 45 most frequent words on mqtt.org
print("Top 30 most frequent words on mqtt.org:")
for word, count in freq.most_common(45):
    print(f"{word:12} {count}")

engine.build_index()

# Show the built index
print("{:<20} | {}".format("term", "DocIDs"))
print("-" * 50)
for term, locations in engine.word_locations.items():
    doc_ids = [loc['DocID'] for loc in locations]
    print("{:<20} | {}".format(term, doc_ids))

"""Block 8: Health Report Functions

"""

def health_report(df, param_checkboxes):
    """
    Displays a colorful health report for the parameters
    (includes information about the last measurement)
    """
    if df is None or df.empty:
        display(HTML("<b style='color:red'>No data for report.</b>"))
        return

    last = df.iloc[-1]
    prev = df.iloc[-2] if len(df) > 1 else last

    rows = []
    issues = []
    fast_change = []

    # Process each parameter and prepare table rows
    for param in param_checkboxes.options:
        if param not in df.columns:
            continue

        val = last[param]
        prev_val = prev[param]

        # Skip missing values
        if pd.isna(val):
            rows.append(
                f"<tr>"
                f"<td style='text-align:left'>{param}</td>"
                f"<td style='text-align:center'><b style='color:gray'>--</b></td>"
                f"<td style='text-align:right'>N/A</td>"
                f"<td style='text-align:right'></td>"
                f"<td></td>"
                f"</tr>"
            )
            continue

        thr = THRESHOLDS.get(param, None)
        tick = "‚úîÔ∏è"
        tick_color = "green"
        show_range = ""

        # Check value range
        if thr:
            show_range = f"{thr['low']} - {thr['high']}"
            if val < thr['low'] or val > thr['high']:
                tick = "‚ùå"
                tick_color = "red"
                issues.append(f"{param}: {val} OUT OF RANGE!")

        # Check for fast changes
        fast_str = ""
        if param in FAST_DELTA and pd.notna(prev_val):
            if abs(val - prev_val) >= FAST_DELTA[param]:
                fast_str = f"<span style='color:purple'>(Œî={val-prev_val:+.2f} change!)</span>"
                issues.append(f"{param}: Fast change Œî={val-prev_val:+.2f}")

        # Build report row
        row = (
            f"<tr>"
            f"<td style='text-align:left'>{param}</td>"
            f"<td style='text-align:center'><b style='color:{tick_color}'>{tick}</b></td>"
            f"<td style='text-align:right'>{val:.1f}</td>"
            f"<td style='text-align:right'>{show_range}</td>"
            f"<td>{fast_str}</td>"
            f"</tr>"
        )
        rows.append(row)

    # Add update time row to the table
    if 'timestamp' in last:
        rows.append(
            f"<tr>"
            f"<td style='text-align:left'><i>Last reading</i></td>"
            f"<td colspan='4' style='text-align:center'><i>{last['timestamp']}</i></td>"
            f"</tr>"
        )

    # Report table - with improved styling
    table = (
        "<table style='border-collapse:collapse; border:1px solid #ddd; width:100%;'>"
        "<tr style='background-color:#f2f2f2;'><th>Parameter</th><th>Status</th><th>Value</th><th>Normal Range</th><th>Œî Change</th></tr>"
        + "".join(rows) +
        "</table>"
    )

    # Report header
    if issues:
        header = "<b style='color:red'>‚ö†Ô∏è Issues detected:</b> " + " | ".join(issues)
    else:
        header = "<b style='color:green'>‚úÖ All values are within normal range.</b>"

    # Display the report
    report = f"{header}<br>{table}"
    display(HTML(report))

    # Additional info - number of measurements and data age
    if 'timestamp' in last:
        try:
            last_time = pd.to_datetime(last['timestamp'])
            now = pd.Timestamp.now()
            time_diff = (now - last_time).total_seconds()
            time_info = ""

            if time_diff < 60:
                time_info = f"Data is {int(time_diff)} seconds old"
            elif time_diff < 3600:
                time_info = f"Data is {int(time_diff / 60)} minutes old"
            else:
                time_info = f"Data is {int(time_diff / 3600)} hours and {int((time_diff % 3600) / 60)} minutes old"

            info_color = "green" if time_diff < 600 else "orange" if time_diff < 3600 else "red"

            display(HTML(f"<div style='font-size:0.9em; color:{info_color};'>{time_info} | Total readings: {len(df)}</div>"))
        except:
            pass

def get_param_alerts(df, name):
    """
    Builds a list of alerts for parameter threshold violations and fast changes.
    """
    alerts = []
    if df is not None and not df.empty:
        last = df.iloc[-1]
        prev = df.iloc[-2] if len(df) > 1 else last
        for param in [c for c in df.columns if c != 'timestamp']:
            if param in THRESHOLDS:
                val = last[param]
                thr = THRESHOLDS[param]
                if pd.notnull(val) and (val < thr['low'] or val > thr['high']):
                    alerts.append(f"{name}: {param}={val} out of range [{thr['low']}-{thr['high']}]")
            if param in FAST_DELTA:
                val = last[param]
                prev_val = prev[param]
                if pd.notnull(val) and pd.notnull(prev_val) and abs(val - prev_val) >= FAST_DELTA[param]:
                    alerts.append(f"{name}: {param} fast change Œî={val-prev_val:+.2f}")
    return alerts

"""Block 9: Data Entry Form

"""

def create_simple_data_form():
    """
    Creates a simple, stable form for adding data to Firebase
    """
    # Create all widgets first
    topic_select = widgets.Dropdown(
        options=[('Indoor', 'indoor'), ('Outdoor', 'outdoor')],
        value='indoor',
        description='Sensor:',
        layout=widgets.Layout(width='200px')
    )

    # Create input fields for all possible parameters
    temp_input = widgets.FloatText(value=25.0, description='Temperature:', layout=widgets.Layout(width='200px'))
    humidity_input = widgets.FloatText(value=50.0, description='Humidity:', layout=widgets.Layout(width='200px'))
    pressure_input = widgets.FloatText(value=1000.0, description='Pressure:', layout=widgets.Layout(width='200px'))
    distance_input = widgets.FloatText(value=100.0, description='Distance:', layout=widgets.Layout(width='200px'))
    dlight_input = widgets.FloatText(value=500.0, description='DLIGHT:', layout=widgets.Layout(width='200px'))

    # Timestamp
    timestamp_input = widgets.Text(
        value=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        description='Timestamp:',
        layout=widgets.Layout(width='300px')
    )

    # Send button
    send_btn = widgets.Button(
        description='Send Data',
        button_style='success',
        icon='check'
    )

    # Output area for messages
    output = widgets.Output()

    # Container for indoor fields
    indoor_fields = widgets.VBox([temp_input, humidity_input, pressure_input, distance_input])

    # Container for outdoor fields
    outdoor_fields = widgets.VBox([temp_input, humidity_input, dlight_input])

    # Main container
    fields_container = widgets.VBox([indoor_fields])

    # Function to toggle fields based on sensor type
    def update_fields(change):
        if topic_select.value == 'indoor':
            fields_container.children = [indoor_fields]
        else:
            fields_container.children = [outdoor_fields]

    # Function to send data
    def send_data(b):
        with output:
            output.clear_output()
            try:
                sensor_type = topic_select.value

                # Build data based on sensor type
                if sensor_type == 'indoor':
                    data = {
                        'Temperature': temp_input.value,
                        'Humidity': humidity_input.value,
                        'Pressure': pressure_input.value,
                        'Distance': distance_input.value,
                        'timestamp': timestamp_input.value
                    }
                else:  # outdoor
                    data = {
                        'Temperature': temp_input.value,
                        'Humidity': humidity_input.value,
                        'DLIGHT': dlight_input.value,
                        'timestamp': timestamp_input.value
                    }

                # Save to Firebase
                save_to_firebase(sensor_type, data)

                # Show success message
                print(f"‚úÖ Data sent successfully to {sensor_type} sensor!")
                print(f"Sent values: {data}")

                # Update timestamp for next entry
                timestamp_input.value = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

                # Log the action
                global admin_log
                if 'admin_log' not in globals():
                    admin_log = []
                admin_log.append(f"{timestamp_input.value}: Manual data added to {sensor_type} sensor.")

            except Exception as e:
                print(f"‚ùå Error: {str(e)}")

    # Connect event handlers
    topic_select.observe(update_fields, names='value')
    send_btn.on_click(send_data)

    # Create final layout
    form = widgets.VBox([
        topic_select,
        fields_container,
        timestamp_input,
        send_btn,
        output
    ])

    return form

"""Block 10: Manager Screen"""

def manager_screen(out):
    """System management screen based on widgets only"""
    global admin_log, df_indoor, df_outdoor
    out.clear_output()

    with out:
        # Main header
        header = widgets.HTML(
            value="<h1 style='color:#2c3e50; padding:10px 0'>üìä System Management Dashboard</h1>"
        )
        display(header)

        # Create action buttons bar
        action_buttons = widgets.HBox([])
        action_buttons.layout.margin = '0 0 20px 0'
        action_buttons.layout.justify_content = 'flex-start'
        action_buttons.layout.gap = '10px'

        # Refresh data button
        refresh_btn = widgets.Button(
            description="üîÑ Refresh Data",
            button_style='info',
            tooltip="Refresh data from Firebase database"
        )

        # Clear data button
        clear_btn = widgets.Button(
            description="üóëÔ∏è Clear Local Data",
            button_style='danger',
            tooltip="Clear all local data (does not affect Firebase)"
        )

        action_buttons.children = [refresh_btn, clear_btn]
        display(action_buttons)

        # Action buttons functionality
        def refresh_data(b):
            try:
                global df_indoor, df_outdoor
                current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                # Load data from Firebase
                indoor_records = load_from_firebase("indoor")
                outdoor_records = load_from_firebase("outdoor")

                old_indoor_len = len(df_indoor) if df_indoor is not None and not df_indoor.empty else 0
                old_outdoor_len = len(df_outdoor) if df_outdoor is not None and not df_outdoor.empty else 0

                if indoor_records:
                    df_indoor = pd.DataFrame(indoor_records)

                if outdoor_records:
                    df_outdoor = pd.DataFrame(outdoor_records)

                new_indoor_len = len(df_indoor) if df_indoor is not None and not df_indoor.empty else 0
                new_outdoor_len = len(df_outdoor) if df_outdoor is not None and not df_outdoor.empty else 0

                # Add log entry
                indoor_diff = new_indoor_len - old_indoor_len
                outdoor_diff = new_outdoor_len - old_outdoor_len
                log_message = f"{current_time}: Data refreshed from Firebase. "

                if indoor_diff != 0 or outdoor_diff != 0:
                    log_message += f"Changes: Indoor {'+' if indoor_diff >= 0 else ''}{indoor_diff}, Outdoor {'+' if outdoor_diff >= 0 else ''}{outdoor_diff}"
                else:
                    log_message += "No changes detected."

                admin_log.append(log_message)

                # Refresh the screen to show updated data
                manager_screen(out)

            except Exception as e:
                current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                admin_log.append(f"{current_time}: Error refreshing data: {str(e)}")
                manager_screen(out)

        def clear_local_data(b):
            try:
                global df_indoor, df_outdoor
                current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

                # Store counts for logging
                indoor_count = len(df_indoor) if df_indoor is not None and not df_indoor.empty else 0
                outdoor_count = len(df_outdoor) if df_outdoor is not None and not df_outdoor.empty else 0

                # Clear dataframes
                df_indoor = pd.DataFrame()
                df_outdoor = pd.DataFrame()

                # Add log entry
                admin_log.append(f"{current_time}: Local data cleared. Removed {indoor_count} indoor and {outdoor_count} outdoor records.")

                # Refresh the screen
                manager_screen(out)

            except Exception as e:
                current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                admin_log.append(f"{current_time}: Error clearing data: {str(e)}")
                manager_screen(out)

        # Connect button handlers
        refresh_btn.on_click(refresh_data)
        clear_btn.on_click(clear_local_data)

        # Create tab for sensor information
        now = pd.Timestamp.now()

        # Helper functions for color adjustment
        def get_time_color(mins):
            if mins < 5:
                return '#4caf50'  # green
            elif mins < 60:
                return '#ff9800'  # orange
            else:
                return '#f44336'  # red

        def get_value_color(param, val):
            if param in THRESHOLDS:
                thr = THRESHOLDS[param]
                if val < thr['low'] or val > thr['high']:
                    return '#f44336'  # red for out of range
            return '#4caf50'  # green for normal

        # ============== Create sensor cards ==============
        sensors_accordion = widgets.Accordion(children=[], selected_index=None)
        sensors_accordion.layout.margin = '10px 0 20px 0'

        sensor_cards = []

        # Card for each sensor
        for i, (df, name) in enumerate([(df_indoor, "Indoor"), (df_outdoor, "Outdoor")]):
            icon = "üè†" if name == "Indoor" else "üå≥"

            if df is None or df.empty:
                # No data for sensor
                status_html = f"""
                <div style="margin-bottom:15px">
                    <span style="display:inline-block; padding:5px 10px; background:#ffebee; color:#f44336;
                           border-radius:15px; font-weight:bold">OFFLINE</span>
                </div>
                <div style="color:#666; margin:5px 0">No data available for this sensor</div>
                """

                status_widget = widgets.HTML(value=status_html)
                sensor_cards.append(widgets.VBox([status_widget]))

            else:
                try:
                    # Existing data - calculate last time
                    last = pd.to_datetime(df['timestamp'].max())
                    total_seconds = (now - last).total_seconds()
                    mins = int(total_seconds // 60)
                    seconds = int(total_seconds % 60)

                    # Determine status
                    if mins < 60:
                        status = "ONLINE"
                        status_bg = "#e8f5e9"
                        status_color = "#4caf50"
                    else:
                        status = "OFFLINE"
                        status_bg = "#ffebee"
                        status_color = "#f44336"

                    # Time format
                    time_str = last.strftime('%Y-%m-%d %H:%M:%S')

                    if mins == 0:
                        time_ago = f"{seconds} seconds ago"
                    elif mins < 60:
                        time_ago = f"{mins} min, {seconds} sec ago"
                    else:
                        hours = mins // 60
                        minutes = mins % 60
                        time_ago = f"{hours} hours, {minutes} min ago"

                    time_color = get_time_color(mins)

                    # Number of readings
                    readings_count = len(df)

                    # Build HTML for card
                    status_html = f"""
                    <div style="margin-bottom:15px">
                        <span style="display:inline-block; padding:5px 10px; background:{status_bg};
                               color:{status_color}; border-radius:15px; font-weight:bold">{status}</span>
                    </div>
                    """

                    # Create basic table for data
                    table_rows = []

                    # Time rows
                    table_rows.append(f"""
                    <tr>
                        <td style="padding:8px 15px; color:#666">Last reading:</td>
                        <td style="padding:8px 15px; font-weight:bold">{time_str}</td>
                    </tr>
                    <tr>
                        <td style="padding:8px 15px; color:#666">Time since update:</td>
                        <td style="padding:8px 15px; font-weight:bold; color:{time_color}">{time_ago}</td>
                    </tr>
                    """)

                    # Parameter rows
                    last_row = df.iloc[-1]

                    # Select parameters based on sensor type
                    if name == "Indoor":
                        key_params = ["Temperature", "Humidity", "Pressure", "Distance"]
                    else:  # Outdoor
                        key_params = ["Temperature", "Humidity", "DLIGHT"]

                    for param in key_params:
                        if param in last_row and pd.notna(last_row[param]):
                            val = last_row[param]
                            val_color = get_value_color(param, val)

                            table_rows.append(f"""
                            <tr>
                                <td style="padding:8px 15px; color:#666">{param}:</td>
                                <td style="padding:8px 15px; font-weight:bold; color:{val_color}">{val:.1f}</td>
                            </tr>
                            """)

                    # Readings count row
                    table_rows.append(f"""
                    <tr>
                        <td style="padding:8px 15px; color:#666">Total readings:</td>
                        <td style="padding:8px 15px;">
                            <span style="background:#f5f5f5; padding:3px 8px; border-radius:10px; font-size:13px">
                                {readings_count}
                            </span>
                        </td>
                    </tr>
                    """)

                    # Create full table
                    table_html = f"""
                    <table style="width:100%; border-collapse:collapse">
                        {"".join(table_rows)}
                    </table>
                    """

                    status_widget = widgets.HTML(value=status_html)
                    table_widget = widgets.HTML(value=table_html)

                    sensor_cards.append(widgets.VBox([status_widget, table_widget]))

                except Exception as e:
                    error_html = f"""
                    <div style="margin-bottom:15px">
                        <span style="display:inline-block; padding:5px 10px; background:#fff8e1;
                               color:#ff9800; border-radius:15px; font-weight:bold">ERROR</span>
                    </div>
                    <div style="color:#666; margin:5px 0">Error processing data: {str(e)}</div>
                    """

                    status_widget = widgets.HTML(value=error_html)
                    sensor_cards.append(widgets.VBox([status_widget]))

        # Add cards to accordion
        sensors_accordion.children = sensor_cards
        sensors_accordion.set_title(0, f"üè† Indoor Sensor")
        sensors_accordion.set_title(1, f"üå≥ Outdoor Sensor")

        # Set accordion with both tabs open
        sensors_accordion.selected_index = None

        # Display accordion
        display(sensors_accordion)

        # ============== Collect alerts and system logs ==============
        alerts_title = widgets.HTML(
            value="<h2 style='margin-top:15px; color:#2c3e50'>‚ö†Ô∏è Active Alerts & System Log</h2>"
        )
        display(alerts_title)

        # Collect alerts
        alerts_list = []
        for df, name in [(df_indoor, "Indoor"), (df_outdoor, "Outdoor")]:
            if df is None or df.empty:
                alerts_list.append(f"{name}: No data received.")
            else:
                try:
                    last = pd.to_datetime(df['timestamp'].max())
                    mins = int((now - last).total_seconds() // 60)
                    if mins > 60:
                        alerts_list.append(f"{name}: No update for {mins} min.")
                except:
                    pass
        alerts_list += get_param_alerts(df_indoor, "Indoor")
        alerts_list += get_param_alerts(df_outdoor, "Outdoor")

        # Create a combined box for alerts and logs
        combined_box = widgets.VBox([])
        combined_box.layout.margin = '10px 0 20px 0'
        combined_box.layout.border = '1px solid #ddd'
        combined_box.layout.padding = '10px'
        combined_box.layout.border_radius = '5px'

        # Alerts section
        alerts_section = widgets.VBox([])
        if alerts_list:
            alert_items = []
            for alert in alerts_list:
                alert_item = widgets.HBox([
                    widgets.HTML(value="<span style='color:#f44336; font-size:18px'>‚ö†Ô∏è</span>"),
                    widgets.Label(value=alert)
                ])
                alert_item.layout.margin = '5px 0'
                alert_items.append(alert_item)
            alerts_section.children = alert_items
        else:
            no_alerts = widgets.HBox([
                widgets.HTML(value="<span style='color:#4caf50; font-size:18px'>‚úÖ</span>"),
                widgets.HTML(value="<span>No active alerts. All systems operating normally.</span>")
            ])
            alerts_section.children = [no_alerts]

        # Log section
        log_section_title = widgets.HTML(
            value="<h3 style='margin:15px 0 10px 0; color:#2c3e50; font-size:16px'>üìã Recent System Activity</h3>"
        )

        log_section = widgets.VBox([])
        log_section.layout.margin = '10px 0 0 0'
        log_section.layout.max_height = '150px'
        log_section.layout.overflow_y = 'auto'

        if not admin_log:
            no_logs = widgets.HTML(value='<div style="text-align: center; color: #777; font-style: italic;">No system activity logged yet</div>')
            log_section.children = [no_logs]
        else:
            log_items = []
            # Display most recent logs first (up to 5)
            for line in list(reversed(admin_log))[:5]:
                parts = line.split(': ', 1)
                if len(parts) == 2:
                    time_part, message_part = parts
                    log_item = widgets.HBox([
                        widgets.HTML(value='<span style="color:#0099ff; margin-right:8px">‚Ä¢</span>'),
                        widgets.HTML(value=f'<span style="color:#666; white-space:nowrap">{time_part}</span>'),
                        widgets.HTML(value=f'<span style="margin-left:8px">{message_part}</span>')
                    ])
                else:
                    log_item = widgets.HBox([
                        widgets.HTML(value='<span style="color:#0099ff; margin-right:8px">‚Ä¢</span>'),
                        widgets.HTML(value=f'<span>{line}</span>')
                    ])
                log_item.layout.margin = '3px 0'
                log_items.append(log_item)

            log_section.children = log_items

        # Combine alerts and logs in one box
        combined_box.children = [alerts_section, log_section_title, log_section]
        display(combined_box)

        # ============== Data entry form ==============
        form_title = widgets.HTML(
            value="<h2 style='margin-top:15px; color:#2c3e50'>üìä Add Data Manually</h2>"
        )
        display(form_title)

        # Use a simpler, more stable approach
        try:
            # Create form container
            form_container = widgets.VBox()
            form_container.layout.border = '1px solid #ddd'
            form_container.layout.padding = '15px'
            form_container.layout.border_radius = '5px'
            form_container.layout.margin = '10px 0'

            # Check if the simple form function exists
            if 'create_simple_data_form' in globals():
                form = create_simple_data_form()
                form_container.children = [form]
            else:
                # Fallback: create inline form
                topic_dropdown = widgets.Dropdown(
                    options=[('Indoor', 'indoor'), ('Outdoor', 'outdoor')],
                    value='indoor',
                    description='Sensor:'
                )

                send_button = widgets.Button(
                    description='Send Data',
                    button_style='success'
                )

                status_output = widgets.Output()

                # Simple send function
                def simple_send(b):
                    with status_output:
                        status_output.clear_output()
                        print(f"Sending data to {topic_dropdown.value} sensor...")
                        try:
                            # Create sample data
                            data = {
                                'Temperature': 25.0,
                                'Humidity': 50.0,
                                'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                            }
                            if topic_dropdown.value == 'indoor':
                                data['Pressure'] = 1000.0
                                data['Distance'] = 100.0
                            else:
                                data['DLIGHT'] = 500.0

                            save_to_firebase(topic_dropdown.value, data)
                            print("‚úÖ Data sent successfully!")
                        except Exception as e:
                            print(f"‚ùå Error: {e}")

                send_button.on_click(simple_send)

                form_container.children = [
                    widgets.HTML("<p>Quick data entry (with default values):</p>"),
                    topic_dropdown,
                    send_button,
                    status_output
                ]

            display(form_container)

        except Exception as e:
            # If all else fails, show error message
            error_container = widgets.HTML(
                value=f"""<div style='color:#ff9800; padding:10px; background:#fff8e1;
                border-radius:5px; margin:10px 0;'>
                ‚ö†Ô∏è Data entry form unavailable. Error: {str(e)}
                </div>"""
            )
            display(error_container)

"""Block 11: Search Screen"""

def search_screen(out):
    """Enhanced search screen with image and animation based on widgets"""
    out.clear_output()
    with out:
        # ‚¨áÔ∏è Logo fade-in
        logo_html = widgets.HTML(
            value="""
            <div style="
                text-align: center;
                margin-bottom: 15px;
                animation: fadeIn 1.5s ease-in-out;
            ">
                <img src="https://raw.githubusercontent.com/noasivan1/cloud_computing_project/main/AntBanger2.png"
                     alt="MQTT Logo"
                     style="
                        width: 180px;
                        max-width: 80%;
                        height: auto;
                        border-radius: 12px;
                        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
                    " />
            </div>
            <style>
                @keyframes fadeIn {
                    from { opacity: 0; transform: translateY(-10px); }
                    to { opacity: 1; transform: translateY(0); }
                }
            </style>
            """
        )
        display(logo_html)

        # Main header
        header = widgets.HTML(
            value="<h1 style='color:#2c3e50; padding:10px 0'>üîç Search Engine</h1>"
        )
        display(header)

        # Brief description of the engine
        description = widgets.HTML(
            value="<p style='margin:0 0 15px 0'>Search through indexed MQTT documentation pages.</p>"
        )
        display(description)

        # Search container and layout
        search_container = widgets.VBox([])
        search_container.layout.margin = '10px 0 20px 0'
        search_container.layout.border = '1px solid #ddd'
        search_container.layout.padding = '15px'
        search_container.layout.border_radius = '5px'
        search_container.layout.background_color = '#f9f9f9'

        # Full-width search field
        query_widget = widgets.Text(
            value='',
            placeholder='Enter search terms (e.g. mqtt protocol, connectivity)',
            description='Search:',
            style={'description_width': 'initial'}
        )
        query_widget.layout.width = '100%'
        query_widget.layout.margin = '0 0 10px 0'

        # Search tips
        search_tips = widgets.HTML(
            value="""<p style="margin:5px 0; font-size:12px; color:#666">
            <b>Search Tips:</b>
            ‚Ä¢ Use simple keywords
            ‚Ä¢ Multiple terms are supported (e.g. <i>mqtt security</i>)
            ‚Ä¢ Common words like "the", "and" are ignored
            </p>"""
        )
         # Search button
        search_button = widgets.Button(
            description="üîç Search",
            button_style='primary',
            tooltip='Execute search with the current query'
        )
        # Clear button
        clear_button = widgets.Button(
            description="‚úï Clear",
            button_style='',
            tooltip='Clear search query and results'
        )
        # Button container
        button_box = widgets.HBox([search_button, clear_button])
        button_box.layout.margin = '10px 0'
        button_box.layout.gap = '10px'

        # Status/error messages
        msg_container = widgets.Box([])
        msg_container.layout.margin = '10px 0'
        msg_container.layout.min_height = '24px'

        msg_label = widgets.HTML(value="")
        msg_container.children = [msg_label]

        # Results area
        results_title = widgets.HTML(value="<h3 style='margin:15px 0 10px 0; font-size:16px; display:none'>Results</h3>")

        output = widgets.Output()
        output.layout.margin = '10px 0'
        output.layout.border = '1px solid #eee'
        output.layout.padding = '10px'
        output.layout.max_height = '400px'
        output.layout.overflow_y = 'auto'
        output.layout.display = 'none'

        # Add all components to search container
        search_container.children = [query_widget, search_tips, button_box, msg_container, results_title, output]
        display(search_container)

         # Function to clear results
        def clear_search(b):
            query_widget.value = ''
            msg_label.value = ""
            results_title.value = "<h3 style='margin:15px 0 10px 0; font-size:16px; display:none'>Results</h3>"
            output.clear_output()
            output.layout.display = 'none'

         # Search function
        def do_search(b=None):
            msg_label.value = "<span style='color:#0099ff;'><i>Searching...</i></span>"
            with output:
                output.clear_output()

            query = query_widget.value.strip()
            if not query:
                msg_label.value = "<span style='color:#ff9800;'>Please enter a search query.</span>"
                return

            try:
               # Use the search logic from the original search function
                search_results = []

                # Process search terms - this validation part is needed here
                lemmatizer = engine.lemmatizer
                stop_words = engine.stop_words
                words = [lemmatizer.lemmatize(w.lower()) for w in re.findall(r'\w+', query)
                         if w.lower() not in stop_words and engine.is_valid_term(w.lower())]

                if not words:
                    msg_label.value = "<span style='color:#ff9800;'>No valid search terms found. Try different keywords.</span>"
                    return

                 # Use the core search logic from the original function
                result_pages = defaultdict(int)
                for word in words:
                    for location in engine.word_locations.get(word, []):
                        result_pages[location['DocID']] += location['Frequency']

                ranked = sorted(result_pages.items(), key=lambda x: -x[1])

                # Collect search results including content snippetsv
                for doc_id, score in ranked[:10]:
                    page = next(p for p in engine.pages if p['id'] == doc_id)
                    title = page['title'] if page['title'] != 'No Title' else f"Document {doc_id}"
                    url = engine.id_url_map.get(doc_id, "URL not found")
                    content_snippet = page['content'][:150].replace('<', '&lt;').replace('>', '&gt;') + "..."

                    search_results.append({
                        'doc_id': doc_id,
                        'title': title,
                        'url': url,
                        'score': score,
                        'snippet': content_snippet
                    })

                # Display results
                with output:
                    output.clear_output()
                    if not search_results:
                        msg_label.value = "<span style='color:#ff9800;'>No results found for your query.</span>"
                        return

                    # Update results title and show result count
                    results_title.value = f"<h3 style='margin:15px 0 10px 0; font-size:16px;'>Found {len(ranked)} Results</h3>"
                    results_title.layout.display = 'block'
                    output.layout.display = 'block'

                     # Results table
                    results_html = f"""
                    <div style="margin-bottom:10px;"><b>Search results for:</b> <i>"{query}"</i></div>
                    <table style="width:100%; border-collapse:collapse; margin-bottom:10px">
                    <tr style="background-color:#f2f2f2; font-weight:bold">
                        <th style="padding:8px; text-align:left; border-bottom:1px solid #ddd">Title</th>
                        <th style="padding:8px; text-align:left; border-bottom:1px solid #ddd">URL</th>
                        <th style="padding:8px; text-align:center; border-bottom:1px solid #ddd">Score</th>
                    </tr>
                    """

                    for result in search_results:
                        results_html += f"""
                        <tr style="border-bottom:1px solid #eee">
                            <td style="padding:8px;"><b>{result['title']}</b></td>
                            <td style="padding:8px;"><a href="{result['url']}" target="_blank">{result['url']}</a></td>
                            <td style="padding:8px; text-align:center">{result['score']}</td>
                        </tr>
                        <tr style="border-bottom:1px solid #ddd">
                            <td colspan="3" style="padding:8px; color:#666; font-size:13px">
                                {result['snippet']}
                            </td>
                        </tr>
                        """

                    results_html += "</table>"
                    display(widgets.HTML(value=results_html))

                    # Update status message
                    msg_label.value = f"<span style='color:#4caf50;'>Found {len(ranked)} results for '{query}'</span>"

            except Exception as e:
                error_msg = f"Error during search: {str(e)}"
                msg_label.value = f"<span style='color:#f44336;'>{error_msg}</span>"

                with output:
                    output.clear_output()
                    print(f"Search Error: {error_msg}")
                    import traceback
                    traceback.print_exc()

         # Connect functions to buttons
        search_button.on_click(do_search)
        clear_button.on_click(clear_search)
        query_widget.on_submit(do_search) # Apply search also when pressing Enter



"""Fake data for statistics block"""

#Generating fake data for statistics screen

# Constants
start_date = datetime(2025, 4, 1)
end_date = datetime(2025, 6, 30)
names = ["Alice", "Bob", "Charlie", "Diana", "Ethan", "Fiona", "George"]
stations = [f"station_{i+1}" for i in range(7)]
date_range = [(start_date + timedelta(days=i)).strftime("%Y-%m-%d")
              for i in range((end_date - start_date).days + 1)]

# Assign each person a fixed station
person_station_map = dict(zip(names, stations))
station_engineer_map = dict(zip(stations, names))

# Generate worker data
workers_data = []
cumulative_points = {name: 0 for name in names}

skill_factor = -2
for date in date_range:
    skill_factor = -2
    for name in names:

        station = person_station_map[name]
        critical = random.choices([0, 1, 2, 3], weights=[60, 25, 10, 5])[0]
        non_critical = critical * random.randint(2, 3)
        points = random.randint(5, 10) + skill_factor
        cumulative_points[name] += points
        skill_factor +=1

        workers_data.append({
            "name": name,
            "date": date,
            "station": station,
            "points_gained": points,
            "cumulative_points": cumulative_points[name],
            "critical_errors_fixed": critical,
            "non_critical_errors_fixed": non_critical
        })

# Generate station data
stations_data = []

station_efficiency=[51.7, 53.2, 46.2, 61.1, 33.3, 51.2, 82.6, 56.5, 72.5]
i=1
for date in date_range:
    i=1
    for station in stations:
        critical = random.choices([0, 1, 2, 3], weights=[60, 25, 10, 5])[0]
        non_critical = critical * random.randint(2, 3)
        #efficiency = round(random.uniform(60, 90), 2)
        efficiency = station_efficiency[i]
        station_efficiency[i] = station_efficiency[i] + (100-station_efficiency[i])*random.uniform(-0.006,0.022)*(i**1.15)
        i+=1
        engineer = station_engineer_map[station]

        stations_data.append({
            "station": station,
            "date": date,
            "critical_errors": critical,
            "non_critical_errors": non_critical,
            "efficiency": efficiency,
            "assigned_engineer": engineer
        })

### create dataframes for fake data for graph illustration

workers_df = pd.DataFrame(workers_data)
stations_df = pd.DataFrame(stations_data)

# Convert date strings to datetime for plotting
workers_df['date'] = pd.to_datetime(workers_df['date'])
stations_df['date'] = pd.to_datetime(stations_df['date'])

"""graph explainer hover button"""

help_icon = widgets.HTML()

def update_help_tooltip(text):
    help_icon.value = f"""
    <div style="
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: help;
        font-size: 20px;
        z-index: 10;
    ">
        ‚ÑπÔ∏è
        <div style="
            display: none;
            position: absolute;
            top: 25px;
            right: 0;
            width: 220px;
            background-color: #f9f9f9;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 10px;
            font-size: 13px;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
        " class="tooltip-text">{text}</div>
    </div>

    <script>
    let parent = this.closest('div');
    if (parent) {{
        let icon = parent.querySelector('div[style*="cursor: help"]');
        if (icon) {{
            icon.addEventListener('mouseenter', () => {{
                icon.querySelector('.tooltip-text').style.display = 'block';
            }});
            icon.addEventListener('mouseleave', () => {{
                icon.querySelector('.tooltip-text').style.display = 'none';
            }});
        }}
    }}
    </script>
    """

"""Block 12: Statistics Screen Function

"""

def stats_screen(out):
    """Statistics screen for sensor and selected parameters - enhanced widget-based version"""
    global df_indoor, df_outdoor

    def plot_by_mode(mode):
      if mode == 'engineer_points':

        df = workers_df.copy()
        df['date'] = pd.to_datetime(df['date'])
        pivot = df.pivot_table(index='date', columns='name', values='cumulative_points', aggfunc='last').ffill()
        pivot.plot(title='Cumulative Points Over Time per Engineer', figsize=(10, 4))
        plt.xlabel("Date")
        plt.ylabel("Cumulative Points")
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()

      elif mode == 'efficiency_trends':
        df = stations_df.copy()
        df['date'] = pd.to_datetime(df['date'])
        pivot = df.pivot_table(index='date', columns='station', values='efficiency', aggfunc='mean')
        pivot.plot(title='Efficiency Trends per Station', figsize=(10, 4))
        plt.xlabel("Date")
        plt.ylabel("Efficiency (%)")
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()

      elif mode == 'station_errors':
        df = stations_df.copy()
        df_grouped = df.groupby('station')[['critical_errors', 'non_critical_errors']].mean()
        df_grouped.plot(kind='bar', stacked=True, figsize=(10, 4), title='Average Errors per Station')
        plt.ylabel("Avg Errors")
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        plt.show()


      elif mode == 'engineer_daily':
        df = workers_df.copy()
        df['date'] = pd.to_datetime(df['date'])

        # Limit to last 30 days
        today = pd.Timestamp.now().normalize()
        start_date = today - pd.Timedelta(days=30)
        df = df[df['date'] >= start_date]

        selected = param_checkboxes.value
        if not selected:
            print("No engineers selected.")
            return

        df = df[df['name'].isin(selected)]

        # Daily sum of points per engineer
        daily = df.groupby(['date', 'name'])['points_gained'].sum().unstack().fillna(0)
        #daily.plot(title="Daily Points Gained per Engineer (Last 30 Days)", figsize=(10, 4))
        daily.plot(kind='bar', stacked=True, title="Daily Points Gained per Engineer (Last 30 Days)", figsize=(12, 5))
        plt.xlabel("Date")
        plt.ylabel("Points Gained")
        plt.grid(True, linestyle='--', alpha=0.7)
        plt.tight_layout()
        ax = plt.gca()
        ax.set_xticks(ax.get_xticks()[::3])  # show every 3rd tick
        ax.set_xticklabels([d.day for i, d in enumerate(daily.index) if i % 3 == 0], rotation=0)
        plt.show()

      elif mode == 'station_daily_errors':
        df = stations_df.copy()
        df['date'] = pd.to_datetime(df['date'])

        # Limit to last 30 days
        today = pd.Timestamp.now().normalize()
        start_date = today - pd.Timedelta(days=30)
        df = df[df['date'] >= start_date]

        selected = param_checkboxes.value
        if not selected:
            print("No stations selected.")
            return

        df = df[df['station'].isin(selected)]

        # Group by date and station, sum errors
        daily = df.groupby(['date', 'station'])[['critical_errors', 'non_critical_errors']].sum()

        # Unstack to get separate columns per station
        for error_type in ['critical_errors', 'non_critical_errors']:
            pivot = daily[error_type].unstack().fillna(0)
            pivot.plot(kind='bar', stacked=True, title=f"{error_type.replace('_', ' ').title()} per Station (Last 30 Days)", figsize=(12, 5))
            plt.xlabel("Date")
            plt.ylabel("Error Count")
            plt.grid(True, linestyle='--', alpha=0.7)
            plt.tight_layout()
            ax = plt.gca()
            ax.set_xticks(ax.get_xticks()[::3])  # show every 3rd tick
            ax.set_xticklabels([d.day for i, d in enumerate(pivot.index) if i % 3 == 0], rotation=0)
            plt.show()

    out.clear_output()
    with out:
        # Main header
        header = widgets.HTML(
            value="<h1 style='color:#2c3e50; padding:10px 0'>üìä Sensor Statistics</h1>"
        )
        display(header)

        # Brief description of the screen
        description = widgets.HTML(
            value="<p style='margin:0 0 15px 0'>View sensor readings statistics and trends over time.</p>"
        )
        display(description)

        # Container for both selection controls AND plot
        main_container = widgets.VBox([])
        main_container.layout.margin = '10px 0 20px 0'
        main_container.layout.border = '1px solid #ddd'
        main_container.layout.padding = '15px'
        main_container.layout.border_radius = '5px'
        main_container.layout.background_color = '#f9f9f9'

        # Title for controls area
        controls_title = widgets.HTML(
            value="<h3 style='margin:0 0 15px 0; font-size:16px;'>Select Data to View</h3>"
        )



        sensor_select = widgets.Dropdown(
         options=[
        ('Indoor Sensor üè†', 'indoor'),
        ('Outdoor Sensor üå≥', 'outdoor'),
        ('Engineer Optimization Points ‚≠ê', 'engineer_points'),
        ('Efficiency Trends üìà', 'efficiency_trends'),
        ('Errors per Station ‚ö†Ô∏è', 'station_errors'),
        ('Engineer Daily Points üìÖ', 'engineer_daily'),
        ('Station Errors Over Time ‚è≥', 'station_daily_errors')
              ],
        value='indoor',
        description='Data to view:',
        style={'description_width': 'initial'}
          )




        sensor_select.layout.width = '300px'
        sensor_select.layout.margin = '0 0 15px 0'

        # Parameter selection with clearer description
        param_select_title = widgets.HTML(
            value="<div style='margin:5px 0'>Select parameters to display (multiple selection):</div>"
        )

        param_checkboxes = widgets.SelectMultiple(
            options=[],
            value=(),
            rows=4,  # Fixed height for better appearance
            layout={'width': '300px'}
        )

        # Refresh data button
        refresh_btn = widgets.Button(
            description="üîÑ Refresh Data",
            button_style='info',
            tooltip="Update with latest data from the database"
        )

        # Create plot area inside main container
        plot_title = widgets.HTML(
            value="<h3 style='margin:15px 0 10px 0; font-size:16px;'>Parameter Trends</h3>"
        )
        plot_output = widgets.Output()
        #plot_output.layout.height = '300px'  # Fixed height for plot
        plot_output.layout.height = 'auto'
        plot_output.layout.overflow_y = 'visible'
        plot_output.layout.margin = '10px 0'

        # Controls section
        controls_section = widgets.VBox([
            controls_title,
            sensor_select,
            param_select_title,
            param_checkboxes,
            refresh_btn
        ])

        # Plot section
        plot_section = widgets.VBox([
            plot_title,
            plot_output
        ])

        # Add controls and plot to main container
        main_container.children = [controls_section, plot_section]
        display(main_container)

        # Container for statistics results
        stats_container = widgets.VBox([])
        stats_container.layout.margin = '20px 0'
        stats_container.layout.border = '1px solid #ddd'
        stats_container.layout.padding = '15px'
        stats_container.layout.border_radius = '5px'

        # Title for statistics area
        stats_title = widgets.HTML(
            value="<h3 style='margin:0 0 15px 0; font-size:16px;'>Statistics Results</h3>"
        )

        # Output area for statistics
        stats_output = widgets.Output()
        stats_output.layout.min_height = '300px'

        # Add components to statistics container
        stats_container.children = [stats_title, stats_output]
        display(stats_container)

        # Function to update parameter options
        def update_param_options(*args):
            if sensor_select.value == 'indoor':
                if df_indoor is not None and not df_indoor.empty:
                    cols = [c for c in df_indoor.columns if c != 'timestamp']
                    param_checkboxes.options = cols

                    # Smart default selection - temperature and humidity if available
                    default_params = []
                    for param in ['Temperature', 'Humidity', 'Pressure', 'Distance']:
                        if param in cols:
                            default_params.append(param)

                    # Select first two parameters as default
                    param_checkboxes.value = tuple(default_params[:2])
                else:
                    param_checkboxes.options = []
                    param_checkboxes.value = ()
            elif sensor_select.value == 'outdoor':
                if df_outdoor is not None and not df_outdoor.empty:
                    cols = [c for c in df_outdoor.columns if c in ['DLIGHT', 'Temperature', 'Humidity']]
                    param_checkboxes.options = cols

                    # Smart default selection for outdoor sensor
                    default_params = []
                    for param in ['Temperature', 'Humidity', 'DLIGHT']:
                        if param in cols:
                            default_params.append(param)

                    param_checkboxes.value = tuple(default_params[:2])
                else:
                    param_checkboxes.options = []
                    param_checkboxes.value = ()

            elif sensor_select.value == 'engineer_daily':
                cols = sorted(workers_df['name'].unique())
                param_checkboxes.options = cols
                param_checkboxes.value = tuple(cols[:1])  # default one engineer

            elif sensor_select.value == 'station_daily_errors':
                cols = sorted(stations_df['station'].unique())
                param_checkboxes.options = cols
                param_checkboxes.value = tuple(cols[:1])


            else:
                    param_checkboxes.options = []
                    param_checkboxes.value = ()

            # Update plot when parameters change
            update_plot()

        # # Function to update the plot

        def update_plot(*args):
          plot_output.clear_output()
          with plot_output:
            mode = sensor_select.value

            # For the new graph modes
            if mode in ['engineer_points', 'efficiency_trends', 'station_errors', 'points_vs_errors', 'engineer_daily', 'station_daily_errors']:
                plot_by_mode(mode)
                return

            # Existing logic for indoor/outdoor
            df = df_indoor if mode == 'indoor' else df_outdoor

            if df is None or df.empty or not param_checkboxes.value:
                print("No data available for plotting or no parameters selected.")
                return

            # Get the most recent records for plotting
            num_recent = min(10, len(df))
            recent = df.tail(num_recent)

            # Prepare data for plotting
            plot_data = recent.copy()
            plot_data.index = range(len(plot_data))

            # Select only the chosen columns that have data
            selected_params = [p for p in param_checkboxes.value if p in plot_data.columns]

            if selected_params and len(plot_data) >= 2:
                # Handle missing values
                plot_data[selected_params] = plot_data[selected_params].ffill()

                # Create plot
                plot_data[selected_params].plot(
                    title=f"Parameter Trends (Last {num_recent} readings)", figsize=(10, 4))
                plt.xlabel("Sample")
                plt.ylabel("Value")
                plt.grid(True, linestyle='--', alpha=0.7)
                plt.legend(loc='best')
                plt.tight_layout()
                plt.show()
            elif len(plot_data) < 2:
                print("Not enough data for plotting (need at least 2 readings)")
            elif not selected_params:
                print("No valid parameters selected for plotting")


        # Function to display statistics
        def show_stats(*args):
            stats_output.clear_output()

            with stats_output:
                df = None
                sensor_name = "Indoor (Room)" if sensor_select.value == 'indoor' else "Outdoor (Environment)"

                # Choose appropriate dataframe
                if sensor_select.value == 'indoor':
                    if df_indoor is not None and not df_indoor.empty:
                        df = df_indoor
                        display(widgets.HTML(f"<h3 style='color:#2c3e50'>{sensor_name} Status Report</h3>"))
                    else:
                        display(widgets.HTML("<div style='color:#f44336; padding:10px; background:#ffebee; border-radius:5px;'>"
                                           "‚ö†Ô∏è No indoor data available.</div>"))
                        return
                else:  # outdoor
                    if df_outdoor is not None and not df_outdoor.empty:
                        df = df_outdoor
                        display(widgets.HTML(f"<h3 style='color:#2c3e50'>{sensor_name} Status Report</h3>"))
                    else:
                        display(widgets.HTML("<div style='color:#f44336; padding:10px; background:#ffebee; border-radius:5px;'>"
                                           "‚ö†Ô∏è No outdoor data available.</div>"))
                        return

                # Check data freshness
                try:
                    last_row = df.iloc[-1]

                    if 'timestamp' in last_row:
                        last_time = pd.to_datetime(last_row['timestamp'])

                        # Last update info with improved styling
                        time_info = widgets.HTML(
                            value=f"<div style='margin-bottom:15px'><b>Last updated:</b> {last_row['timestamp']}</div>"
                        )
                        display(time_info)

                        now = pd.Timestamp.now()
                        time_diff = now - last_time
                        seconds_diff = time_diff.total_seconds()

                        # Warning if data is old
                        if seconds_diff > 3600:  # More than an hour
                            warning = widgets.HTML(
                                value=f"<div style='color:#ff9800; padding:10px; background:#fff8e1; border-radius:5px; margin-bottom:15px'>"
                                      f"‚ö†Ô∏è Warning: Data is {int(seconds_diff / 60)} minutes old</div>"
                            )
                            display(warning)
                except Exception as e:
                    error = widgets.HTML(
                        value=f"<div style='color:#f44336; padding:10px; background:#ffebee; border-radius:5px; margin-bottom:15px'>"
                              f"‚ùå Error checking timestamp: {str(e)}</div>"
                    )
                    display(error)

                # Original health report but with output processing
                health_output = widgets.Output()
                with health_output:
                    health_report(df, param_checkboxes)
                display(health_output)

                # Compute statistics for the 5-10 most recent readings
                num_recent = min(10, len(df))
                recent = df.tail(num_recent)

                # Display recent statistics in table format
                stats_html = f"""
                <h4 style='margin:20px 0 10px 0'>Recent Measurements (last {num_recent} readings)</h4>
                <table style='width:100%; border-collapse:collapse; margin-bottom:15px'>
                <tr style='background-color:#f2f2f2'>
                    <th style='padding:8px; text-align:left; border-bottom:1px solid #ddd'>Parameter</th>
                    <th style='padding:8px; text-align:center; border-bottom:1px solid #ddd'>Average</th>
                    <th style='padding:8px; text-align:center; border-bottom:1px solid #ddd'>Min</th>
                    <th style='padding:8px; text-align:center; border-bottom:1px solid #ddd'>Max</th>
                </tr>
                """

                # Calculate statistics for each parameter
                for param in param_checkboxes.options:
                    if param in df.columns:
                        # Handle missing values
                        valid_values = recent[param].dropna()
                        if len(valid_values) > 0:
                            min_val = valid_values.min()
                            max_val = valid_values.max()
                            avg_val = valid_values.mean()

                            # Set color based on threshold violation
                            val_color = "#4caf50"  # Green by default
                            if param in THRESHOLDS:
                                thr = THRESHOLDS[param]
                                if avg_val < thr['low'] or avg_val > thr['high']:
                                    val_color = "#f44336"  # Red for out of range

                            stats_html += f"""
                            <tr style='border-bottom:1px solid #eee'>
                                <td style='padding:8px; font-weight:bold'>{param}</td>
                                <td style='padding:8px; text-align:center; color:{val_color}'>{avg_val:.2f}</td>
                                <td style='padding:8px; text-align:center'>{min_val:.1f}</td>
                                <td style='padding:8px; text-align:center'>{max_val:.1f}</td>
                            </tr>
                            """
                        else:
                            stats_html += f"""
                            <tr style='border-bottom:1px solid #eee'>
                                <td style='padding:8px; font-weight:bold'>{param}</td>
                                <td colspan='3' style='padding:8px; text-align:center; color:#999'>No valid values</td>
                            </tr>
                            """

                stats_html += "</table>"
                display(widgets.HTML(value=stats_html))

                # Calculate change (delta) from previous reading in styled table
                if len(df) > 1:
                    last = df.iloc[-1]
                    prev = df.iloc[-2]

                    # Changes table
                    delta_html = """
                    <h4 style='margin:20px 0 10px 0'>Parameter Changes (Œî from previous reading)</h4>
                    <table style='width:100%; border-collapse:collapse; margin-bottom:15px'>
                    <tr style='background-color:#f2f2f2'>
                        <th style='padding:8px; text-align:left; border-bottom:1px solid #ddd'>Parameter</th>
                        <th style='padding:8px; text-align:center; border-bottom:1px solid #ddd'>Change (Œî)</th>
                    </tr>
                    """

                    for param in [c for c in df.columns if c != 'timestamp']:
                        if param in df.columns:
                            if pd.notna(last[param]) and pd.notna(prev[param]):
                                delta = last[param] - prev[param]

                                # Set color based on change magnitude
                                delta_color = "#666"  # Default - gray

                                if param in FAST_DELTA:
                                    threshold = FAST_DELTA[param]
                                    if abs(delta) >= threshold:
                                        delta_color = "#f44336"  # Large change - red

                                delta_html += f"""
                                <tr style='border-bottom:1px solid #eee'>
                                    <td style='padding:8px; font-weight:bold'>{param}</td>
                                    <td style='padding:8px; text-align:center; color:{delta_color}; font-weight:bold'>
                                        {delta:+.2f}
                                    </td>
                                </tr>
                                """
                            else:
                                delta_html += f"""
                                <tr style='border-bottom:1px solid #eee'>
                                    <td style='padding:8px; font-weight:bold'>{param}</td>
                                    <td style='padding:8px; text-align:center; color:#999'>N/A</td>
                                </tr>
                                """

                    delta_html += "</table>"
                    display(widgets.HTML(value=delta_html))

        # Function to refresh data
        def refresh_stats_data(b):
            # Refresh data from database
            global df_indoor, df_outdoor

            # Show loading message
            stats_output.clear_output()
            plot_output.clear_output()

            with stats_output:
                display(widgets.HTML("<div style='text-align:center; padding:30px;'><i>Loading data...</i></div>"))

            # Load data from Firebase
            try:
                indoor_records = load_from_firebase("indoor")
                outdoor_records = load_from_firebase("outdoor")

                if indoor_records:
                    df_indoor = pd.DataFrame(indoor_records)

                if outdoor_records:
                    df_outdoor = pd.DataFrame(outdoor_records)

                # Update available parameters for selection
                update_param_options()

                # Display updated data
                show_stats()
                update_plot()
            except Exception as e:
                with stats_output:
                    stats_output.clear_output()
                    display(widgets.HTML(
                        f"<div style='color:#f44336; padding:15px; background:#ffebee; border-radius:5px'>"
                        f"‚ùå Error refreshing data: {str(e)}</div>"
                    ))

        # Connect update functions to events
        refresh_btn.on_click(refresh_stats_data)
        sensor_select.observe(update_param_options, names='value')
        sensor_select.observe(show_stats, names='value')
        param_checkboxes.observe(show_stats, names='value')
        param_checkboxes.observe(update_plot, names='value')

        # Initial display of data
        update_param_options()
        show_stats()
        update_plot()

"""Block 13: Main UI Tabs Setup

"""

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# 0) Fetch & tag
indoor_raw  = load_from_firebase("indoor")
outdoor_raw = load_from_firebase("outdoor")

for r in indoor_raw:   r["__topic"] = "indoor"
for r in outdoor_raw:  r["__topic"] = "outdoor"

# 1) join and DataFrame
all_records = indoor_raw + outdoor_raw
df = pd.DataFrame(all_records)
df["timestamp"] = pd.to_datetime(df["timestamp"])

# 2) Compute per‚Äêtopic ABSOLUTE deltas
for field in FAST_DELTA:
    df[f"{field}_delta"] = (
        df
        .groupby("__topic")[field]
        .diff()
        .abs()
    )

# 3) time windows
TIMEFRAME_CONFIG = {
    '1d': {'period': pd.Timedelta(days=1),   'min_interval': pd.Timedelta(minutes=5)},
    '1w': {'period': pd.Timedelta(weeks=1),  'min_interval': pd.Timedelta(minutes=30)},
    '1m': {'period': pd.Timedelta(days=31),  'min_interval': pd.Timedelta(hours=1)},
}

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# 4) Fault History page widgets
timeframe_w = widgets.ToggleButtons(
    options=[('Last 24 h','1d'), ('Last week','1w'), ('Last month','1m')],
    description='Window:',
    value='1w'
)
show_all_w = widgets.Checkbox(
    value=False,
    description='Show ALL abnormals'
)

# Sorting widgets
sort_column_w = widgets.Dropdown(
    options=["timestamp", "topic", "abnormal_fields"],
    value="timestamp",
    description="Sort by:"
)
sort_asc_w = widgets.Checkbox(
    value=False,
    description="Ascending"
)

fault_out = widgets.Output()  # dedicated Output for Fault History
fault_page = widgets.VBox([
    widgets.HBox([timeframe_w, show_all_w, sort_column_w, sort_asc_w]),
    fault_out
])

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
def highlight_abnormal(row):
    abn = row['abnormal_fields']
    styles = []
    for col in row.index:
        style = ''
        if not col.endswith('_delta'):
            if col in abn:
                style = 'color: red; font-weight: bold;'
        else:
            base = col[:-6]
            dv   = row[col]
            dmax = FAST_DELTA.get(base, None)
            if f"{base}Œî" in abn and pd.notna(dv) and dmax is not None and dv > dmax:
                style = 'color: red; font-weight: bold;'
        styles.append(style)
    return styles

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
## ◊ú◊î◊í◊©◊î ◊î◊°◊ï◊§◊ô◊™ - ◊ú◊©◊†◊ï◊™ ◊ú◊ï◊í◊ô◊ß◊î ◊ú◊ë◊†◊ô◊ô◊™ ◊î◊ò◊ë◊ú◊î ◊ë◊ê◊ï◊§◊ü ◊ì◊ô◊†◊ê◊û◊ô ◊ú◊§◊ô ◊ì◊®◊ô◊©◊ï◊™ ◊î◊û◊©◊™◊û◊©. ◊ú◊ì◊ï◊í◊û◊î, ◊ê◊ù ◊ê◊†◊ô ◊®◊ï◊¶◊î ◊ú◊®◊ê◊ï◊™ ◊®◊ß ◊ê◊™ ◊î◊ó◊®◊ô◊í◊ï◊™ ◊©◊î◊ô◊ï ◊ë◊ò◊û◊§◊®◊ò◊ï◊®◊î ◊ï◊ë◊ì◊ú◊™◊ê ◊©◊ú ◊î◊ú◊ó◊ï◊™ ◊ë◊ú◊ë◊ì
## ◊ê◊ñ ◊™◊î◊ô◊î ◊ê◊§◊©◊®◊ï◊™ ◊ú◊ë◊ó◊ï◊® ◊ê◊™ ◊î◊¢◊®◊õ◊ô◊ù ◊ï◊î◊ò◊ë◊ú◊î ◊©◊™◊ï◊¶◊í ◊™◊õ◊ô◊ú ◊®◊ß ◊ê◊™ ◊î◊¢◊û◊ï◊ì◊ï◊™ ◊î◊ê◊ú◊ï ◊û◊õ◊ú ◊î◊ó◊ô◊ô◊©◊†◊ô◊ù
## ◊ú◊ê◊ó◊® ◊î◊ï◊°◊§◊™ ◊î◊§◊ô◊¶'◊® ◊î◊ñ◊î ◊ú◊ê ◊†◊¶◊ò◊®◊ö ◊ê◊™ ◊¢◊û◊ï◊ì◊™ ◊î◊ê◊ë◊†◊ï◊®◊û◊ú ◊§◊ô◊ú◊ì◊° ◊û◊õ◊ô◊ï◊ï◊ü ◊©◊†◊®◊ê◊î ◊û◊ú◊õ◊™◊ó◊ô◊ú◊î ◊®◊ß ◊ê◊™ ◊î◊®◊ú◊ï◊ï◊†◊ò◊ô◊ù
def fault_history(_=None):
    """Always writes into fault_out."""
    with fault_out:
        clear_output(wait=True)

        # filter by timeframe
        cfg   = TIMEFRAME_CONFIG[timeframe_w.value]
        cutoff = pd.Timestamp.now() - cfg['period']
        subdf  = df[df['timestamp'] >= cutoff]

        abn_rows = []
        for topic, group in subdf.groupby("__topic"):
            grp = group.sort_values("timestamp")

            # optional down-sample
            if not show_all_w.value:
                sampled, last_ts = [], None
                for _, row in grp.iterrows():
                    ts = row.timestamp
                    if last_ts is None or (ts - last_ts) >= cfg['min_interval']:
                        sampled.append(row)
                        last_ts = ts
                grp = pd.DataFrame(sampled)

            # scan each row
            for _, row in grp.iterrows():
                bad = []
                # raw thresholds
                for f, th in THRESHOLDS.items():
                    v = row.get(f)
                    if pd.notna(v) and v != 0 and (v < th['low'] or v > th['high']):
                        bad.append(f)
                # delta thresholds
                for f, dmax in FAST_DELTA.items():
                    dv = row.get(f"{f}_delta")
                    if pd.notna(dv) and dv > dmax:
                        bad.append(f + 'Œî')
                if bad:
                    rec = row.to_dict()
                    rec["__abnormal_fields"] = bad
                    abn_rows.append(rec)

        # render table
        if abn_rows:
            abn_df = (pd.DataFrame(abn_rows)
                      .rename(columns={
                          "__topic": "topic",
                          "__abnormal_fields": "abnormal_fields"
                      }))

            # Apply sorting based on widgets
            sort_col = sort_column_w.value
            ascending = sort_asc_w.value
            abn_df = abn_df.sort_values(sort_col, ascending=ascending).reset_index(drop=True)

            cols = ["timestamp","topic","abnormal_fields"] + [
                c for c in abn_df.columns
                if c not in ("timestamp","topic","abnormal_fields")
            ]
            df_show = abn_df[cols]

            fmt = {c: "{:.2f}" for c in df_show.select_dtypes("number")}
            styled = (df_show
                      .style
                      .apply(highlight_abnormal, axis=1)
                      .format(fmt)
                      .set_table_styles([
                          {'selector': 'th', 'props': [('text-align', 'left')]},
                          {'selector': 'td', 'props': [('text-align', 'left')]}
                      ]))
            display(styled)
        else:
            print("No abnormalities in that window.")

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# Hook controls
timeframe_w.observe(fault_history, 'value')
show_all_w.observe(fault_history, 'value')
sort_column_w.observe(fault_history, 'value')
sort_asc_w.observe(fault_history, 'value')

fault_page = widgets.VBox([
    widgets.HBox([timeframe_w, show_all_w, sort_asc_w, widgets.Label("Sort by:"), sort_column_w]),
    fault_out
])
sort_column_w.observe(fault_history, 'value')

outputs = [widgets.Output() for _ in range(4)]
tabs = widgets.Tab()
tabs.children = outputs
tab_titles = ['Manager', 'Search', 'Statistics', 'Fault History']
for i, title in enumerate(tab_titles):
    tabs.set_title(i, title)

def on_tab_change(change):
    if change['type'] == 'change' and change['name'] == 'selected_index':
        idx = tabs.selected_index
        if idx == 0:
            outputs[0].clear_output()
            manager_screen(outputs[0])
        elif idx == 1:
            outputs[1].clear_output()
            search_screen(outputs[1])
        elif idx == 2:
            outputs[2].clear_output()
            stats_screen(outputs[2])
        elif idx == 3:
            outputs[3].clear_output()
            with outputs[3]:
                display(fault_page)
                fault_history()

tabs.observe(on_tab_change, names='selected_index')
display(tabs)

# Initial manager screen draw
manager_screen(outputs[0])